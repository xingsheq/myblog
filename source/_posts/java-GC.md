---
title: java-GC
date: 2018-02-08 10:23:46
tags: [java,gc,垃圾回收]
category: jdk
---

# 如何判断是否可以回收

1. 引用计数，相互引用，无法释放

2. 可达性算法，从GC Root向下搜索引用链，不在链上的可以回收

   可作为gc root的对象：
   （1）**栈**中局部变量的引用对象
   （2）**方法区**类**静态**属性的引用对象
   （3）**方法区常量**引用对象
   （4）本地方法**栈**中引用对象

# 回收算法

1. 标记清除：老年代，效率不高，空间碎片；
2. 复制算法：新生代Eden，Survivor from ,Survivor to,在对象存活率高的情况下，效率低
3. 标记整理：老年代，存活对象移向一端；
4. 分代收集：新生代，老年代，永久代(java类，方法，使用动态代理生产class)，
   - 新生代Eden满->minorGC
   - 老年代满->FullGC

# 垃圾收集器

1. 新生代:Serial（单线程）、Parallel New（多线程）、Parallel Scavenge（吞吐优先）**都是复制算法**
2. 老年代:Serial Old（单线程）、Parallel Old（吞吐优先）、CMS（最短回收停顿，并发）**除cms为标记清除，其他为标记整理**
3. G1收集器：
   - **标记整理**算法，
   - 作用于Java堆，新老代都回收，
   - 可设置停顿比例，
   - 并发，堆被划分成 许多个连续的区域(region)，
   - G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。

# 对象内存分配过程

1. 优先分配到线程本地缓冲区TLAB(Thread Local Allocation Buffer)，
2. 如果TLAB不能分配，在Eden分配，TLAB属于Eden一部分
3. 大对象直接进老年代：长字符串及数组
4. 长期存活对象进老年代，15次
5. 动态年龄判断，不是所有都需要15次，

# 引用

当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象，Java对引用的概念进行了扩充，将引用分为四种，这四种引用强度依次逐渐减弱。

1. 强引用（Strong Reference）：
2. 软引用（Soft Reference）：溢出前回收
3. 弱引用（Weak Reference）：gc时回收
4. 虚引用（Phantom Reference）：为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知

# 方法区的回收

- 常量池回收：无引用
- 类型卸载：实例已回收，且加载该类的classLoader已回收，无任何引用